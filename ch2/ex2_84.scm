(use compat.sicp)

(define (level type) (get 'level type))

(put-level 'level 'scheme-number 1)
(put-level 'level 'rational 2)
(put-level 'level 'real-number 3)
(put-level 'level 'complex 4)

(define (apply-generic op . args)
    (define (raise-to-same-types args)
        (let ((type-tags (map type-tag args)))
            (let ((a1 (car args))
                  (a2 (cadr args))
                  (level1 (level (car type-tags)))
                  (level2 (level (cadr type-tags))))
                (cond ((= level1 level2) args)
                      ((> level1 level2)
                          (raise-to-same-types (list a1 (raise a2))))
                      ((< level1 level2)
                          (raise-to-same-types (list (raise a1) a2)))))))
    (define (get-proc args)
        (get op (map type-tag args)))
    (define (no-method-error op args)
        (error "No method for these types" (list op (map type-tag args))))
    (let ((proc (get-proc args)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((raised-args (raise-to-same-types args)))
                    (let ((proc (get-proc args)))
                        (if proc
                            (apply proc (map contents raised-args))
                            (no-method-error op args))))
                (no-method-error op args)))))
